<?xml version="1.0" encoding="utf-8"?>
<s:VGroup xmlns:fx="http://ns.adobe.com/mxml/2009" 
		  xmlns:s="library://ns.adobe.com/flex/spark" 
		  xmlns:mx="library://ns.adobe.com/flex/mx"
		  paddingTop="5"
		  paddingBottom="5"
		  paddingLeft="5"
		  paddingRight="5"
		  creationComplete="onInit()"
		  >
	<fx:Declarations>
		<fx:Component id="priceColumnRenderer">
			<s:DefaultGridItemRenderer
				textAlign="right"
				/>
		</fx:Component>
	</fx:Declarations>
	<s:HGroup width="100%">
		<s:Label text="Search:" verticalAlign="middle" height="100%"/>
		<s:TextInput id="filter" prompt="enter partial name, number or customer ID" width="100%" height="{Data.BAR_HEIGHT}" change="onFilterChange()"/>
	</s:HGroup>
	<s:HGroup width="100%">
		<s:CheckBox id="limitDatesCheckbox" label="Limit Dates:" selected="true" height="100%" change="onFilterChange()"/>
		<s:HGroup enabled="{limitDatesCheckbox.selected}">
			<mx:DateField id="dateFrom" width="160" scaleX="1.8" scaleY="1.8" change="onFilterChange()"/>
			<s:Label text="To:" verticalAlign="middle" height="100%"/>
			<mx:DateField id="dateTo" width="160" scaleX="1.8" scaleY="1.8" change="onFilterChange()"/>
		</s:HGroup>
		<s:Line height="100%">
			<s:stroke><s:SolidColorStroke color="#aaaaaa" weight="1"/></s:stroke>
		</s:Line>
		<s:CheckBox label="Show Paid" selected="true" height="100%"/>
	</s:HGroup>
	<s:Line width="100%">
		<s:stroke><s:SolidColorStroke color="#aaaaaa" weight="1"/></s:stroke>
	</s:Line>
	<s:DataGrid
		id="orders"
		width="100%" height="100%" 
		sortableColumns="true" 
		dataProvider="{Data.instance.orders}"
		doubleClick="onDoubleClick()"
		doubleClickEnabled="true"
		>
		<s:columns>
			<s:ArrayList>
				<s:GridColumn dataField="id" headerText="Ticket"/>
				<s:GridColumn labelFunction="customerLabelFunction" headerText="Customer"/>
				<s:GridColumn labelFunction="dropOffLabelFunction" headerText="Drop Off Time"/>
				<s:GridColumn labelFunction="pickUpLabelFunction" headerText="Pick Up Time"/>
				<s:GridColumn dataField="total" headerText="Total" formatter="{Utils.currencyFormatter}" headerRenderer="CustomGridHeaderRenderer" itemRenderer="{priceColumnRenderer}"/>
				<s:GridColumn dataField="paid" headerText="Paid" formatter="{Utils.currencyFormatter}" headerRenderer="CustomGridHeaderRenderer" itemRenderer="{priceColumnRenderer}"/>
			</s:ArrayList>
		</s:columns>
	</s:DataGrid>

	<fx:Script>
		<![CDATA[
			import data.Data;
			import data.Order;
			
			import mx.containers.Grid;
			import mx.controls.Alert;
			import mx.core.IFlexDisplayObject;
			import mx.managers.PopUpManager;
			
			import ui.Dialog;
			import ui.DialogEvent;
			private function onInit():void
			{
				filter.setFocus();
				
				var date:Date = new Date();
				date.time -= Utils.daysToTime(7);
				dateFrom.selectedDate = date;
				
				date = new Date();
				date.time += Utils.daysToTime(7);
				dateTo.selectedDate = date;
			}
			static private function customerLabelFunction(orderObj:Order, column:GridColumn):String
			{
				const customerObj:Object = Data.instance.getCustomer(orderObj.customerID);
				return customerObj ? (customerObj.last + ", " + customerObj.first + ", " + Utils.phoneFormatter.format(customerObj.phone)) : "";
			}
			static private function dropOffLabelFunction(orderObj:Order, column:GridColumn):String
			{
				var date:Date = new Date;
				date.time = orderObj.creationTime;
				return date.toLocaleString();
			}
			static private function pickUpLabelFunction(orderObj:Order, column:GridColumn):String
			{
				var date:Date = new Date;
				date.time = orderObj.pickupTime;
				return date.toLocaleString();
			}
			private function onFilterChange():void
			{
				const pattern:Array = filter.text.toUpperCase().split(" "); 
				Data.instance.orders.filterFunction = function(item:Order):Boolean
				{
					if (limitDatesCheckbox.selected)
					{
						const fromDate:Number = dateFrom.selectedDate.time;
						const toDate:Number = dateTo.selectedDate.time + Utils.daysToTime(1);
						const dateMatch:Boolean = 
							(fromDate <= item.pickupTime && toDate >= item.pickupTime) ||
							(fromDate <= item.creationTime && toDate >= item.creationTime);
						
						if (!dateMatch)
						{
							return false;
						}
					}
					
					const customer:Object = Data.instance.getCustomer(item.customerID);
					// AND on all words, each pattern part must match something
					for each (var patternPart:String in pattern)
					{
						if (!(Utils.matches(String(item.id), patternPart) || (customer && Utils.customerMatchesPattern(customer, patternPart))))
						{
							return false;
						}
					}
					return true;
				};
				Data.instance.orders.refresh();
			}
			private var _currentPopup:IFlexDisplayObject;
			private function onDoubleClick():void
			{
				//KAI: null check
				var orderEditor:OrderEditor = new OrderEditor;
				const order:Order = Order(orders.selectedItem);
				orderEditor.order = order.deepCopy();
				orderEditor.percentHeight = 100;
				orderEditor.percentWidth = 100;
				orderEditor.asPopup = true;
				
				var popup:Dialog = new Dialog;
				popup.height = height;
				popup.bodyContent = orderEditor;
				popup.addButton(Dialog.BTN_DONE);
				popup.title = customerLabelFunction(order, null) + " Total:" + Utils.currencyFormatter.format(order.total) + ", Paid:" + Utils.currencyFormatter.format(order.paid); 

				_currentPopup = popup;
				PopUpManager.addPopUp(popup, parent);
				// KAI: with the right combination of percent height, centerPopUp was causing an infinite loop!  
				// Flex seems stuck in a measure -> invalidate -> measure kinda thing under validateNow().
				// Fixed it with the popup.height setting above
				PopUpManager.centerPopUp(popup);
				popup.y = 0;

				popup.addEventListener(Event.COMPLETE, onOrderEditorClose, false, 0, true);
			}
			private function onOrderEditorClose(e:DialogEvent):void
			{
				if (e.cause == Dialog.BTN_CANCEL)
				{
					// this is incredibly complicated, and is due to the fact that OrderEditor handles its own
					// "are you sure" mechanism, but we'll get called back with onOrderEditorClose right away, potentially
					OrderEditor(Dialog(_currentPopup).bodyContent).runDirtyPrompt();
				}
				else
				{
					hideEditor();
				}
			}
			private function hideEditor():void
			{
				if (_currentPopup)
				{
					PopUpManager.removePopUp(_currentPopup);
					_currentPopup = null;
				}
			}
		]]>
	</fx:Script>
</s:VGroup>
